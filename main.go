package main

import (
	"flag"
	"fmt"
	"log"
	"net/http"
	"path"

	"go/build"

	"github.com/calsol/teleserver/can"
	"github.com/calsol/teleserver/embedded"
	"github.com/calsol/teleserver/lib"
	"github.com/gorilla/mux"
	"github.com/gorilla/websocket"
	"github.com/stvnrhodes/broadcaster"
	"github.com/tarm/goserial"
)

const basePkg = "github.com/calsol/teleserver"

func main() {
	port := flag.Int("port", 8080, "Port for the webserver")
	uart := flag.String("serial", "", "Serial port for talking to the car")
	baud := flag.Int("baud", 115200, "Baud rate for the serial port")
	canAddr := flag.String("can_addr", "", "Port for SocketCAN.")
	fake := flag.Bool("fake", false, "Generate fake data and ignore serial")
	file := flag.String("log_file", "_tmp", "Prefix for the log file. The log file name is based on the time")
	embed := flag.Bool("use_embedded", false, "Use the embedded files generated by go-bindata to make the binary portable")
	flag.Parse()

	b := broadcaster.New()
	go lib.LogToFile(*file, b)

	if *fake {
		go lib.GenFake(b)
	} else if *uart != "" {
		p, err := serial.OpenPort(&serial.Config{Name: *uart, Baud: *baud})
		if err != nil {
			log.Fatal(err)
		}
		defer p.Close()
		go lib.ReadCAN(lib.NewXSPCANReader(p), b)
	} else if *canAddr != "" {
		c, err := can.Dial(*canAddr)
		if err != nil {
			log.Fatal(err)
		}
		defer c.Close()
		go lib.ReadCAN(lib.NewSocketCANReader(c), b)
	} else {
		fmt.Println("    Must use -fake or supply valid port to -serial or -can.")
		fmt.Println("    - fake will generate fake sinusoidal data.")
		fmt.Println("    - If on windows serial port will look like COM45.")
		fmt.Println("    - If on a *nix, serial port will look like /dev/tty.usbmodem1412")
		fmt.Println("    - can only works on a system with SocketCAN, and will probably be can0 or similar.")
		return
	}

	r := mux.NewRouter()
	r.HandleFunc("/ws", lib.ServeWS(b, &websocket.Upgrader{}))
	r.HandleFunc("/data/{name}.json", lib.ServeJSON(b))

	if *embed {
		log.Println("Serving embedded content")
		r.PathPrefix("/").HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			file := path.Join("public", r.URL.Path)
			b, err := embedded.Asset(file)
			if err != nil {
				b, err = embedded.Asset(path.Join(file, "index.html"))
				if err != nil {
					http.Error(w, "Could not find "+file, 404)
					return
				}
			}
			switch path.Ext(file) {
			case ".css":
				w.Header().Set("Content-Type", "text/css")
			case ".js":
				w.Header().Set("Content-Type", "application/javascript")
			}
			w.Write(b)
		})

	} else {
		// Find and serve the files in /public
		p, err := build.Default.Import(basePkg, "", build.FindOnly)
		if err != nil {
			log.Fatalf("Couldn't find resource files: %v", err)
		}
		root := path.Join(p.Dir, "public")
		log.Println("Serving content from", root)
		r.PathPrefix("/").Handler(http.FileServer(http.Dir(root)))
	}
	log.Printf("Starting server on port %v", *port)
	log.Fatal(http.ListenAndServe(fmt.Sprintf(":%d", *port), r))
}
